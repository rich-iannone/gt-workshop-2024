---
output: html
html-table-processing: none
jupyter: python3
---

For this code-along we are going to make a complete table using the
`coffee_sales` dataset. Though there are lots of datasets available in the Great
Tables package, this is not one of them. We'll import the data as a CSV (TODO:
currently it's a JSON file) using Polars first.

But before doing that, we need to import a few things from both Polars and Great
Tables:

```{python}
import polars as pl
import polars.selectors as cs
from great_tables import GT, loc, style
```

Now let's read in the data from the file and inspect the Polars DataFrame: 

```{python}
coffee_sales = pl.DataFrame.deserialize("data/coffee-sales.json", format="json")

coffee_sales
```

The first thing to do is to introduce the DataFrame to the `GT()` class. We'll
assign this to `gt_tbl` and print the table to the viewer:

```{python}
gt_tbl = GT(coffee_sales)

gt_tbl
```

In the viewer we see the HTML table! It's not at all presentable but it has
everything we need to make it look great. Now we have to use the collection of
methods within the Great Tables API to craft the table to something that is
presentation worthy. 

## Adding Structure to the Table

Let's add a table header with the `.tab_header()` method. It takes two arguments:
(1) `title=` and (2) `subtitle=`. We'll just use `title=` for this table.

```{python}
gt_tbl = gt_tbl.tab_header(title="Sales of Coffee Equipment")

gt_tbl
```

It's now time to add spanners over some of the columns. Spanners are useful for
organizing a table's columns into logical groupings. This will also be where we
first use the Polars selectors (`cs.*()`) well. In this case, we'll use
`cs.starts_with()` to target columns within each use of `.tab_spanner()`.

```{python}

gt_tbl = (
    gt_tbl
    .tab_spanner(label="Revenue", columns=cs.starts_with("revenue"))
    .tab_spanner(label="Profit", columns=cs.starts_with("profit"))
)

gt_tbl
```

So long as the columns are named systematically, the combination of Polars
selector functions and `.tab_spanner()` works exceedingly well as it's usage is
somewhat intuitive.

## Formatting Values Within the Table Body

Great Tables comes with a variety of formatting methods. All of them are of the
form: `.fmt_*()` and they're meant to format values in the table body.

Given this table deals with sales data, we have columns that are monetary values
and they need to be formatted. We can do that either with `.fmt_currency()` or
with `.fmt_number()`. In this case, we'll use `.fmt_number()` to perform the
formatting of numeric values to currency values.

Let's do the following things:

1. target the columns that contain revenue values
2. use 'compact' numbers (e.g., 134,523 -> 135K)
3. manually affix the dollar sign to the value with `pattern=`
4. Ensure that we only see three numbers for each formatted value

```{python}
gt_tbl = (
    gt_tbl
    .fmt_number(
        columns=cs.ends_with("dollars"),
        compact=True,
        pattern="${x}",
        n_sigfig=3,
    )
)

gt_tbl
```

We've formatted the revenue values and that's good. But we also have fractional
values (i.e., between `0` and `1`) that need to be formatted. They would present
better as percentage values so let's use `.fmt_percent()` for this task. Here,
we have to target the correct columns and we'd prefer to see no decimal values
in the formatted output.

```{python}
gt_tbl = (
    gt_tbl
    .fmt_percent(
        columns=cs.ends_with("pct"),
        decimals=0
    )
)

gt_tbl
```

This formatting looks great! Much better than without the formatting in place
because now this is now easier to parse and to understand.

## Styling the Table

```{python}
gt_tbl = (
    gt_tbl
    .tab_style(
        style=style.fill(color="aliceblue"),
        locations=loc.body(columns=cs.starts_with("revenue"))
    )
)

gt_tbl
```




```{python}
gt_tbl = (
    gt_tbl
    .tab_style(
        style=style.fill(color="papayawhip"),
        locations=loc.body(columns=cs.starts_with("profit"))
    )
)

gt_tbl
```




```{python}
gt_tbl = (
    gt_tbl
    .tab_style(
        style=style.text(weight="bold"),
        locations=loc.body(rows=pl.col("product") == "Total"),
    )
)

gt_tbl
```


## Adding a Column of Nanoplots

```{python}
gt_tbl = (
    gt_tbl
    .fmt_nanoplot(
        columns="monthly_sales",
        plot_type="bar"
    )
)

gt_tbl
```


## Adding Images to the Table

```{python}
gt_tbl = (
    gt_tbl
    .fmt_image(
        columns="icon",
        path="img/"
    )
)

gt_tbl
```



## Making Some Final Tweaks

There's a missing value in the table and it appears as the text `"None"`. We
don't want that in the final table. There's a method dedicated to replacing
missing values in the table body and it's called `.sub_missing()`. It has a
`columns=` argument but, by default, the method targets *all columns*. Here,
we will replace `"None"` such that we get an empty cell.

```{python}
gt_tbl = gt_tbl.sub_missing(missing_text="")

gt_tbl
```

Now, we will replace the column labels with better labels for display purposes.
Usually, you'll never want to keep the original labels since they're derived
from the column names of the input DataFrame. Instead, we'll use `.cols_label()`
to re-label all of the column labels.

```{python}
gt_tbl = (
    gt_tbl
    .cols_label(
        revenue_dollars="Amount",
        profit_dollars="Amount",
        revenue_pct="Percent",
        profit_pct="Percent",
        monthly_sales="Monthly Sales",
        icon="",
        product="Product",
    )
)

gt_tbl
```

Note that we could have used `.cols_label()` much earlier. We delayed the use of
this method because it's sometimes easier to iterate on GT code when you can see
the original column names of the table in the viewer. 
