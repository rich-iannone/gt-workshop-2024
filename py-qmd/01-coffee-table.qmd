---
output: html
html-table-processing: none
jupyter: python3
---

For this code-along we are going to make a complete table using the
`coffee_sales` dataset. Though there are lots of datasets available in the Great
Tables package, this is not one of them. We'll import the data as a CSV (TODO:
currently it's a JSON file) using Polars first.

But before doing that, we need to import a few things from both Polars and Great
Tables:

```{python}
import polars as pl
import polars.selectors as cs
from great_tables import GT, loc, style
```

Now let's read in the data from the file and inspect the Polars DataFrame: 

```{python}
coffee_sales = pl.DataFrame.deserialize("data/coffee-sales.json", format="json")

coffee_sales
```

The first thing to do is to introduce the DataFrame to the `GT()` class. We'll
assign this to `gt_tbl` and print the table to the viewer:

```{python}
gt_tbl = GT(coffee_sales)

gt_tbl
```


## Adding Structure to the Table

Let's add a table header with the `.tab_header()` method. It takes two arguments:
(1) `title=` and (2) `subtitle=`. We'll just use `title=` for this table.

```{python}
gt_tbl = gt_tbl.tab_header(title="Sales of Coffee Equipment")

gt_tbl
```

It's now time to add spanners over some of the columns. Spanners are useful for
organizing a table's columns into logical groupings. This will also be where we
first use the Polars selectors (`cs.*()`) well. In this case, we'll use
`cs.starts_with()` to target columns within each use of `.tab_spanner()`.

```{python}

gt_tbl = (
    gt_tbl
    .tab_spanner(label="Revenue", columns=cs.starts_with("revenue"))
    .tab_spanner(label="Profit", columns=cs.starts_with("profit"))
)

gt_tbl
```

## Formatting Values Within the Table Body

```{python}
gt_tbl = (
    gt_tbl
    .fmt_number(
        columns=cs.ends_with("dollars"),
        compact=True,
        pattern="${x}",
        n_sigfig=3,
    )
)

gt_tbl
```




```{python}
gt_tbl = (
    gt_tbl
    .fmt_percent(
        columns=cs.ends_with("pct"),
        decimals=0
    )
)

gt_tbl
```


## Styling the Table

```{python}
gt_tbl = (
    gt_tbl
    .tab_style(
        style=style.fill(color="aliceblue"),
        locations=loc.body(columns=cs.starts_with("revenue"))
    )
)

gt_tbl
```




```{python}
gt_tbl = (
    gt_tbl
    .tab_style(
        style=style.fill(color="papayawhip"),
        locations=loc.body(columns=cs.starts_with("profit"))
    )
)

gt_tbl
```




```{python}
gt_tbl = (
    gt_tbl
    .tab_style(
        style=style.text(weight="bold"),
        locations=loc.body(rows=pl.col("product") == "Total"),
    )
)

gt_tbl
```


## Adding a Column of Nanoplots

```{python}
gt_tbl = (
    gt_tbl
    .fmt_nanoplot(
        columns="monthly_sales",
        plot_type="bar"
    )
)

gt_tbl
```


## Adding Images to the Table

```{python}
gt_tbl = (
    gt_tbl
    .fmt_image(
        columns="icon",
        path="img/"
    )
)

gt_tbl
```



## Making Some Final Tweaks

There's a missing value in the table and it appears as the text `"None"`. We
don't want that in the final table. There's a method dedicated to replacing
missing values in the table body and it's called `.sub_missing()`. It has a
`columns=` argument but, by default, the method targets *all columns*. Here,
we will replace `"None"` such that we get an empty cell.

```{python}
gt_tbl = gt_tbl.sub_missing(missing_text="")

gt_tbl
```

Now, we will replace the column labels with better labels for display purposes.
Usually, you'll never want to keep the original labels since they're derived
from the column names of the input DataFrame. Instead, we'll use `.cols_label()`
to re-label all of the column labels.

```{python}
gt_tbl = (
    gt_tbl
    .cols_label(
        revenue_dollars="Amount",
        profit_dollars="Amount",
        revenue_pct="Percent",
        profit_pct="Percent",
        monthly_sales="Monthly Sales",
        icon="",
        product="Product",
    )
)

gt_tbl
```

Note that we could have used `.cols_label()` much earlier. We delayed the use of
this method because it's sometimes easier to iterate on GT code when you can see
the original column names of the table in the viewer. 
