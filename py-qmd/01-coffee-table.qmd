---
output: html
html-table-processing: none
jupyter: python3
---

For this code-along we are going to make a complete table using the
`coffee_sales` dataset. Though there are lots of datasets available in the Great
Tables package, this is not one of them. We'll import the data using Polars, 
resulting in a Polars DataFrame.

But before doing that, we need to import a few things from both Polars and Great
Tables:

```{python}
import polars as pl
import polars.selectors as cs
from great_tables import GT, loc, style
```

The first import, `import polars as pl` imports the main module of Polars. The
second one imports the `selectors` module as `cs` (short for column selectors).
The third gets a few key things from Great Tables:

- `GT`: the main class of Great Tables and entry point into the API
- `loc`: the module for targeting table locations/cell, used here for styling
- `style`: the module for defining styles; will be used alongside `loc`

Now let's read in the data from the file and inspect the Polars DataFrame: 

```{python}
coffee_sales = pl.DataFrame.deserialize("data/coffee-sales.json", format="json")

coffee_sales
```

The first thing to do is to introduce the DataFrame to the `GT()` class. We'll
assign this to `gt_tbl` and print the table to the viewer:

```{python}
gt_tbl = GT(coffee_sales)

gt_tbl
```

In the viewer we see the HTML table! It's not at all presentable but it has
everything we need to make it look great. Now we have to use the collection of
methods within the Great Tables API to craft the table to something that is
presentation worthy. 

## Adding Structure to the Table

Let's add a table header with the `.tab_header()` method. It takes two arguments:
(1) `title=` and (2) `subtitle=`. We'll just use `title=` for this table.

```{python}
gt_tbl = gt_tbl.tab_header(title="Sales of Coffee Equipment")

gt_tbl
```

It's now time to add spanners over some of the columns. Spanners are useful for
organizing a table's columns into logical groupings. This will also be where we
first use the Polars selectors (`cs.*()`). In this case, we'll use
`cs.starts_with()` to target columns within each use of `.tab_spanner()`.

```{python}

gt_tbl = (
    gt_tbl
    .tab_spanner(label="Revenue", columns=cs.starts_with("revenue"))
    .tab_spanner(label="Profit", columns=cs.starts_with("profit"))
)

gt_tbl
```

So long as the columns are named systematically, the combination of Polars
selector functions and `.tab_spanner()` works exceedingly well as it's usage is
somewhat intuitive.

## Formatting Values Within the Table Body

Great Tables comes with a variety of formatting methods. All of them are of the
form: `.fmt_*()` and they're meant to format values in the table body.

Given this table deals with sales data, we have columns that are monetary values
and they need to be formatted. We can do that either with `.fmt_currency()` or
with `.fmt_number()`. In this case, we'll use `.fmt_number()` to perform the
formatting of numeric values to currency values.

Let's do the following things:

1. target the columns that contain revenue values
2. use 'compact' numbers (e.g., 134,523 -> 135K)
3. manually affix the dollar sign to the value with `pattern=`
4. Ensure that we only see three numbers for each formatted value

```{python}
gt_tbl = (
    gt_tbl
    .fmt_number(
        columns=cs.ends_with("dollars"),
        compact=True,
        pattern="${x}",
        n_sigfig=3,
    )
)

gt_tbl
```

We've formatted the revenue values and that's good. But we also have fractional
values (i.e., between `0` and `1`) that need to be formatted. They would present
better as percentage values so let's use `.fmt_percent()` for this task. Here,
we have to target the correct columns and we'd prefer to see no decimal values
in the formatted output.

```{python}
gt_tbl = (
    gt_tbl
    .fmt_percent(
        columns=cs.ends_with("pct"),
        decimals=0
    )
)

gt_tbl
```

This formatting looks great! Much better than without the formatting in place
because this is all now easier to parse and to understand.

## Styling the Table

Table styling involves things like:

- modifying cell background colors
- styling any and all text (color, weight, capitalizing, changing size, etc.)
- altering the cell borders (line color, line type, etc.)

We'll do some of that here with the coffee table. Starting with adding cell
background color.

Let's target the cells underneath the columns dealing with sales revenue. The
`.tab_style()` method is what needs to be used for this. There's a bit to unpack
here, let's start with the two arguments of that method:

1. `style=`: for defining the styles; use the `style` helper here
2. `locations=`: for where the styles are applied; use the `loc` helper here

The `style` module has a few functions: (1) `style.fill()`, (2) `style.text()`,
and (3) `style.borders()`. Each has their own specialized arguments for cell
fill, text, and border properties. We need to use the first one here (and its
`color=` argument).

With the `loc` module, for specifying a location to style, we'll use
`loc.body()` function, which has the `columns=` and `rows=` arguments.

Okay, let's now color fill those cells dealing with revenue. The color will be
`"aliceblue"`:

```{python}
gt_tbl = (
    gt_tbl
    .tab_style(
        style=style.fill(color="aliceblue"),
        locations=loc.body(columns=cs.starts_with("revenue"))
    )
)

gt_tbl
```

Alright! Those cells now have a nice, light-blue color.

Now, let's do pretty much the same thing, except with the columns dealing with
profit. The color fill to use will be `"papayawhip"` here:

```{python}
gt_tbl = (
    gt_tbl
    .tab_style(
        style=style.fill(color="papayawhip"),
        locations=loc.body(columns=cs.starts_with("profit"))
    )
)

gt_tbl
```

Excellent. There is now much color within the table, thanks to `.tab_style()`.

There is a summary row at the bottom of the table. It contains totals and it
would stand out more if the text was more prominent. For this, we're going to
target the entire row in `loc.body()`. We'll use `style.text(weight="bold")` to
achieve a bolded text look in the row. 

```{python}
gt_tbl = (
    gt_tbl
    .tab_style(
        style=style.text(weight="bold"),
        locations=loc.body(rows=pl.col("product") == "Total"),
    )
)

gt_tbl
```

To get that done we used a Polars column expression. This one:

`pl.col("product") == "Total"`

How does this work? By default, `loc.body()` will target all columns, so, we
don't use the `columns=` argument in `loc.body()`. Instead we use `rows=` and
the expression returns the row index where there is the text `"Total"` in the
`product` column.

## Adding a Column of Nanoplots

Nanoplots are tiny, interactive plots that pack a lot of data into individual
body cells. We have a list column in `monthly_sales` the `.fmt_nanoplot()`
method can take a list column as acceptable input to generate a plot. The
default `plot_type` is `"line"` but for this table we want some `"bar"`-based
nanoplots. Here's how we do it:

```{python}
gt_tbl = (
    gt_tbl
    .fmt_nanoplot(
        columns="monthly_sales",
        plot_type="bar"
    )
)

gt_tbl
```

Try interacting with the nanoplots in the viewer. Note that hovering over any of
the bars provides the numerical value for the data point. If you hover over the
region to the left of the bars, the scale will be revealed. Nanoplots are pretty
powerful and we'll learn even more about them later on in the workshop.

## Adding Images to the Table

Sometimes, icon graphics in the table could aid in readability. We have a series
of PNG images in the `img` directory. We can use them in the table with the
formatting method called `.fmt_image()`. As input, the body cells need to have
the filenames of the images as text. You then specify a path to the images and
they are inserted as Base64-encoded images (makes it all self-contained and
portable). In our table, the column to use this on is the `icon` column:

```{python}
gt_tbl = (
    gt_tbl
    .fmt_image(
        columns="icon",
        path="img/"
    )
)

gt_tbl
```

Now we have icons in that column, making the table that much more easier to scan
for sales/profit data.

## Making Some Final Tweaks

There's a missing value in the table and it appears as the text `"None"`. We
don't want that in the final table. There's a method dedicated to replacing
missing values in the table body and it's called `.sub_missing()`. It has a
`columns=` argument but, by default, the method targets *all columns*. Here,
we will replace `"None"` such that we get an empty cell.

```{python}
gt_tbl = gt_tbl.sub_missing(missing_text="")

gt_tbl
```

Now, we will replace the column labels with better labels for display purposes.
Usually, you'll never want to keep the original labels since they're derived
from the column names of the input DataFrame. Instead, we'll use `.cols_label()`
to re-label all of the column labels.

```{python}
gt_tbl = (
    gt_tbl
    .cols_label(
        revenue_dollars="Amount",
        profit_dollars="Amount",
        revenue_pct="Percent",
        profit_pct="Percent",
        monthly_sales="Monthly Sales",
        icon="",
        product="Product",
    )
)

gt_tbl
```

Note that we could have used `.cols_label()` much earlier. We delayed the use of
this method because it's sometimes easier to iterate on GT code when you can see
the original column names of the table in the viewer.

# Exercises: Coffee Table

Now that you have a working table, there's a few things you should experiment
with:

1. Try making the Nanoplots as line plots.
2. Experiment with `nanoplot_options()`: you have to use that helper in the
`options` argument (this function needs to be imported as well)
3. Try formatting the `*dollars` columns with `.fmt_currency()`, play around
with the options in that method
4. Export the table as an image file. Use the `.save()` method for this task.
