---
output: html
html-table-processing: none
---

# Coffee Table: gt

For this lesson we are going to make a complete table using the `coffee_sales`
dataset. Though there are lots of datasets available in the gt package, this is
not one of them. We'll import the CSV data as a tibble object.

But before doing that, we need to ensure that gt and tidyverse is loaded:

```{r}
library(gt)
library(tidyverse)
```

Now let's read in the data from the CSV file. We'll use `readr::read_csv()` for
this, and a tibble will be returned. We will print it out to inspect the data: 

```{r}
coffee_sales <- readr::read_csv("data/coffee-sales.csv")

coffee_sales
```

When making a display table with gt, the first thing is always to introduce the
tibble to the `gt()` function. We'll assign this to `gt_tbl` and print the table
to the viewer:

```{r}
gt_tbl <- gt(coffee_sales)

gt_tbl
```

In the viewer we see the HTML table! It's not at all presentable but it has
everything we need to make it look great. Now we have to use the collection of
functions within the gt API to craft the table to something that is presentation
worthy.

## Adding Structure to the Table

Let's add a table header with the `tab_header()` function. It takes two
arguments: (1) `title` and (2) `subtitle`. We'll just use `title` for this
table.

```{r}
gt_tbl <- gt_tbl |> tab_header(title = "Sales of Coffee Equipment")

gt_tbl
```

It's now time to add spanners over some of the columns. Spanners are useful for
organizing a table's columns into logical groupings. This will also be where we
first use the select helpers. In this case, we'll use `starts_with()` to target
columns within each use of `tab_spanner()`.

```{r}
gt_tbl <-
    gt_tbl |>
    tab_spanner(label = "Revenue", columns = starts_with("revenue")) |>
    tab_spanner(label = "Profit", columns = starts_with("profit"))

gt_tbl
```

So long as the columns are named systematically, the combination of a select
helper and `tab_spanner()` works exceedingly well as it's usage is somewhat
intuitive.

Now, we will replace the column labels with better labels for display purposes.
Usually, you'll never want to keep the original labels since they're derived
from the column names of the input tibble. Instead, we'll use `cols_label()`
to re-label all of the column labels.

```{r}
gt_tbl <-
    gt_tbl |>
    cols_label(
        icon = "",
        product = "Product",
        revenue_dollars = "Amount",
        profit_dollars = "Amount",
        revenue_pct = "Percent",
        profit_pct = "Percent"
    )

gt_tbl
```

## Formatting Values Within the Table Body

The gt package comes with a variety of formatting functions. All of them are of
the form: `fmt_*()` and they're meant to format values in the table body.

```{r}
gt_tbl <- 
    gt_tbl |>
    fmt_currency(
        columns = ends_with("dollars"),
        use_subunits = FALSE
    )

gt_tbl
```

We've formatted the revenue values and that's good. But we also have fractional
values (i.e., between `0` and `1`) that need to be formatted. They would present
better as percentage values so let's use `fmt_percent()` for this task. Here,
we have to target the correct columns and we'd prefer to see no decimal values
in the formatted output.

```{r}
gt_tbl <-
    gt_tbl |>
    fmt_percent(
        columns = ends_with("pct"),
        decimals = 0
    )

gt_tbl
```

This formatting looks great! Much better than without the formatting in place
because this is all now easier to parse and to understand.

## Styling the Table

Table styling involves things like:

- modifying cell background colors
- styling any and all text (color, weight, capitalizing, changing size, etc.)
- altering the cell borders (line color, line type, etc.)

We'll do some of that here with the coffee table. Starting with adding cell
background color.

Let's target the cells underneath the columns dealing with sales revenue. The
`tab_style()` function is what needs to be used for this. There's a bit to
unpack here, let's start with the two arguments of that method:

1. `style`: for defining the styles; use a `cell_*()` function here
2. `locations`: for where the styles are applied; use a `cells_*` function here

There are three styling helpers: (1) `cell_fill()`, (2) `cell_text()`,
and (3) `cell_borders()`. Each has their own specialized arguments for cell
fill, text, and border properties. We need to use the first one here (and its
`color` argument).

For specifying a location to style, we'll use the `cells_body()` function, which
has the `columns` and `rows` arguments.

Okay, let's now color fill those cells dealing with revenue. The color will be
`"aliceblue"`:

```{r}
gt_tbl <-
    gt_tbl |>
    tab_style(
        style = cell_fill(color = "aliceblue"),
        locations = cells_body(columns = starts_with("revenue"))
    )

gt_tbl
```

Alright! Those cells now have a nice, light-blue color.

Now, let's do pretty much the same thing, except with the columns dealing with
profit. The color fill to use will be `"papayawhip"` here:

```{r}
gt_tbl <-
    gt_tbl |>
    tab_style(
        style = cell_fill(color = "papayawhip"),
        locations = cells_body(columns = starts_with("profit"))
    )

gt_tbl
```

Excellent. There is now much color within the table, thanks to `tab_style()`.

There is a summary row at the bottom of the table. It contains totals and it
would stand out more if the text was more prominent. For this, we're going to
target the entire row in `cells_body()`. We'll use `cell_text(weight = "bold")`
to achieve a bolded text look in the row. 

```{r}
gt_tbl <-
    gt_tbl |>
    tab_style(
        style = cell_text(weight = "bold"),
        locations = cells_body(rows = product == "Total")
    )
```

To get that done we used an R expression. This one:

`product == "Total"`

How does this work? By default, `cells_body()` will target all columns, so, we
don't use the `columns` argument in `cells_body()`. Instead we use `rows` and
the expression returns the row index where there is the text `"Total"` in the
`product` column.

## Adding a Column of Nanoplots

Nanoplots are tiny, interactive plots that pack a lot of data into individual
body cells. We have a list column in `monthly_sales` the `cols_nanoplot()`
function can take a generate a column of nanoplots. The default `plot_type` is
`"line"` but for this table we want some `"bar"`-based nanoplots. Here's how we
do it:

```{r}
gt_tbl <-
    gt_tbl |>
    cols_nanoplot(
        columns = monthly_sales, 
        plot_type = "bar",
        new_col_name = "nanoplots",
        new_col_label = "Monthly Revenue" 
    )

gt_tbl
```

Try interacting with the nanoplots in the viewer. Note that hovering over any of
the bars provides the numerical value for the data point. If you hover over the
region to the left of the bars, the scale will be revealed. Nanoplots are pretty
powerful and we'll learn even more about them later on in the workshop.

## Adding Images to the Table

Sometimes, icon graphics in the table could aid in readability. We have a series
of PNG images in the `img` directory. We can use them in the table with the
formatting function called `fmt_image()`. As input, the body cells need to have
the filenames of the images as text. You then specify a path to the images and
they are inserted as Base64-encoded images (makes it all self-contained and
portable). In our table, the column to use this on is the `icon` column:

```{r}
gt_tbl <-
    gt_tbl |>
    fmt_image(
        columns = icon,
        path = "img/"
    )

gt_tbl
```

Now we have icons in that column, making the table that much more easier to scan
for sales/profit data.

## Making Some Final Tweaks

There's a missing value in the table and it appears as the text `"NA"`. We don't
want that in the final table. There's a function dedicated to replacing missing
values in the table body and it's called `sub_missing()`. It has a `columns`
argument but, by default, the function targets *all columns*. Here, we will
replace `"NA"` such that we get an empty cell.

```{r}
gt_tbl <- gt_tbl |> sub_missing(missing_text = "")

gt_tbl
```
