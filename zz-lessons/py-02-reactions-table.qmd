---
output: html
html-table-processing: none
jupyter: python3
---

# Reactions Table: Great Tables

## Start

In this lesson we are going to make a complete table using the `reactions`
dataset available in the Great Tables package. Before that, we need to import a
few things from both Polars and Great Tables:

```{python}
import polars as pl
import polars.selectors as cs
from great_tables import GT, md
from great_tables.data import reactions
```

The imports from Polars are the same as in the previous module. From Great
Tables we need:

- `GT`: the main class of Great Tables and entry point into the API
- `md`: a helper function for declaring that new text is provided as Markdown
- `reactions`: a dataset from the `data` module

The `reactions` dataset is pretty large and not conducive to being a summary
data in its original form. Let's transform it to a Polars DataFrame and perform
some data transformations to make it much smaller. 

```{python}
reactions_mini = (
    pl.from_pandas(reactions)
    .filter(pl.col("cmpd_type") == "mercaptan")
    .select([
        "cmpd_name",
        "cmpd_formula",
        cs.ends_with("k298")
    ])
    .with_columns(
        cmpd_formula=pl.concat_str(
            "%" + pl.col("cmpd_formula") + "%"
        )
    )
)

reactions_mini
```

The `reactions_mini` DataFrame now contains 11 rows over six columns. 

The next thing to do is to introduce the DataFrame to the `GT()` class. We'll
assign this to `gt_tbl` and print the table to the viewer:

```{python}
gt_tbl_1 = GT(reactions_mini, rowname_col="cmpd_name")

gt_tbl_1
```

In this case we are creating a stub column by providing the name of the column
containing row labels. We do this with the `rowname_col=` argument. Note that
the compound names in the table don't have a column label above (that cell is
now the stubhead label, which is absent). Also, there is a dividing line between
the stub and the table body.

## Adding Structure to the Table

Let's add a table header with the `.tab_header()` method. We'll just elect to
provide a title here. We're using the `md()` helper function to mark the title
text as Markdown text. The word `"mercaptan"` will be rendered as bold text due
to the use of `"**"` around the word.

```{python}
gt_tbl_2 = gt_tbl_1.tab_header(
    title=md("Gas-phase reactions of selected **mercaptan** compounds")
)

gt_tbl_2
```

It's now time to add a spanner label over some of the columns and we do this
with `.tab_spanner()`. We'll use `cs.ends_with()` to target the columns ending
with `"k298"`. For this spanner label we are using units notation which is
within the opening `"{{"` and closing `"}}"`. 

```{python}
gt_tbl_3 = (
    gt_tbl_2
    .tab_spanner(
        columns=cs.ends_with("k298"),
        label="Reaction Rate Constant (298 K),<br>{{cm^3 molecules^–1 s^–1}}"
    )
)

gt_tbl_3
```

Here, the units notation text has superscripted numeric values for all of the
individual units. The caret character `"^"` followed by the numeric value (e.g.,
`"s^-1"`) indicates that these exponent values should be rendered as superscript
numerals.

Now, we will replace the column labels with better labels for display purposes.
Usually, you'll never want to keep the original labels since they're derived
from the column names of the input DataFrame. Instead, we'll use `.cols_label()`
to re-label all of the column labels.

```{python}
gt_tbl_4 = (
    gt_tbl_3
    .cols_label(
        cmpd_formula="",
        OH_k298="OH",
        O3_k298="{{%O3%}}",
        NO3_k298="{{%NO3%}}",
        Cl_k298="Cl"
    )
)

gt_tbl_4
```

## Formatting Values Within the Table Body

Units notation can have a sub-notation called chemistry notation. That is
delimited by `"%"` characters. An example of this is: `"Amt, {{mmol %C6H6%}}"`.
The `.fmt_units()` method processes text in units notation in the table body.
It doesn't need the `"{{"` / `"}}"` delimiters in the text but the `"%"`
characters are needed. That's present in the `cmpd_formula` column and so using
`.fmt_units()` there will interpret the text values as being in chemistry
notation.

```{python}
gt_tbl_5 = gt_tbl_4.fmt_units(columns="cmpd_formula")

gt_tbl_5
```

The unformatted values in the `*k298` columns would present much better when
formatted in scientific notation. We can do that by using the
`.fmt_scientific()` method. Here, we use `cs.ends_with("k298")` to target all
of the relevant columns by a common part of their column names.

```{python}
gt_tbl_6 = gt_tbl_5.fmt_scientific(columns=cs.ends_with("k298"))

gt_tbl_6
```

It makes sense to have these values in scientific notation because readers are
used to seeing such values represented that way. It makes comparing your values
to other values in the literature that much easier.

There is an abundance of missing values in the table (the `"None"` values). We
can substitute the text of these cells with alternative text. Here, we are going
to do the simplest thing: just call the `.sub_missing()` method with its
defaults:

```{python}
gt_tbl_7 = gt_tbl_6.sub_missing()

gt_tbl_7
```

Note that all missing values in all columns are replaced (i.e., we didn't have
to supply any sort of statement in the `columns=` argument). Also, the default
replacement is a long dash (an 'em dash'). If you'd like anything other than
that, then the `missing_text=` argument should be used.

Now, we see that the `O3_k298` column has nothing but missing values. It's an
entire column of dashes. You may want to keep this in the table, or, you may
decide it is of little value. In the latter case, you can 'hide' the column from
final presentation by using the `.cols_hide()` method. Let's do that here and
specify only that column in `columns=`:

```{python}
gt_tbl_8 = gt_tbl_7.cols_hide(columns="O3_k298")

gt_tbl_8
```

The `O3_k298` column is no longer visible in the table. The useful thing about
`.cols_hide()` is that we can have column values that may have useful data for
expressions (i.e., good and convenient for building the table) but their values
may not be useful for the finalized table display.

## Styling the Table

We can style the table using specific options within the `.tab_options()` method
but it can be easier to start with `.opt_stylize()` since it will systematically
theme your entire table with a simple call. There are two arguments here:

- `style=`: choose a numbered style from `1` to `6`
- `color=`: a base color, options are `"blue"`, `"cyan"`, `"pink"`, `"green"`,
`"red"`, and `"gray"`

Let's go with `style=1` and `color="blue"`

```{python}
gt_tbl_9 = gt_tbl_8.opt_stylize(style=1, color="blue")

gt_tbl_9
```

There are 36 combinations of `style=` and `color=` so play around with them and
see what looks good to you. Also, you can further modify the appearance of the
table by using `.tab_options()` or `.tab_style()`.

## Making Some Final Tweaks

The default set of fonts for the table (*set* because of multi-platform
considerations) is pleasant but sometimes having something different desirable.
With `.opt_table_font()` we can easily set a font for the entire table or draw
from a set of font *stacks*. In the statement below we'll ignore the `font=`
argument and instead use `stack=`, supplying the keyword `"humanist"`:

```{python}
gt_tbl_10 = gt_tbl_9.opt_table_font(stack="humanist")

gt_tbl_10
```

There are several `stack=` values to choose from:

- `"system-ui"`
- `"transitional"`
- `"old-style"`
- `"humanist"`
- `"geometric-humanist"`
- `"classical-humanist"`
- `"neo-grotesque"`
- `"monospace-slab-serif"`
- `"monospace-code"`
- `"industrial"`
- `"rounded-sans"`
- `"slab-serif"`
- `"antique"`
- `"didone"`
- `"handwritten"`

Choosing `"humanist"` means the following set of fonts will be used (in this
order):

- `"Seravek"`
- `"Gill Sans Nova"`
- `"Ubuntu"`
- `"Calibri"`
- `"DejaVu Sans"`
- `"source-sans-pro"`
- `"sans-serif"`

The fonts have a similar look and the set of fallbacks is designed such that
there's a good chance one of the fonts will be available independent of the
operating system or platform.

The final tweak is all about spacing. We can give the side-by-side values a bit
more space to breathe by increasing left and right cell padding. We can do this
consistently (and easily) with the `.opt_horizontal_padding()` method. The only
argument is `scale=` and the value provided has to be between `0` and `3`.
Larger values (`>1`) mean more space, small values (`<1`) decrease the
horizontal space.

```{python}
gt_tbl_11 = gt_tbl_10.opt_horizontal_padding(scale=3)

gt_tbl_11
```

Play around with the `scale=` value to determine how amount of extra space is
needed (it may be none, but it's good to try it out). Note that there is also
a `.opt_vertical_padding()` method that operates similarly but modifies top and
bottom padding instead.
